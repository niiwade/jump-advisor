"use strict";(()=>{var e={};e.id=429,e.ids=[429],e.modules={1708:e=>{e.exports=require("node:process")},3295:e=>{e.exports=require("next/dist/server/app-render/after-task-async-storage.external.js")},4573:e=>{e.exports=require("node:buffer")},6111:(e,t,a)=>{a.d(t,{a:()=>c,z:()=>d});var r=a(70132),o=a(11572),i=a(94112);function s(e,t){return e?new Date(e):t?new Date(t):new Date}async function n(e){let t=new(await Promise.resolve().then(a.bind(a,40276))).OpenAI({apiKey:process.env.OPENAI_API_KEY});return(await t.embeddings.create({model:"text-embedding-ada-002",input:e})).data[0].embedding}async function d(e,t,a){try{if(console.log(`Processing calendar update for user ${e}, resource ${t}, state ${a}`),!await r.z.account.findFirst({where:{userId:e,provider:"google"}}))throw Error(`No Google account found for user ${e}`);let i=await (0,o.Im)(e);if("not_exists"===a)return void await p(e,t);let s=await i.events.get({calendarId:"primary",eventId:t});if(!s.data)return void console.log(`No event data found for ${t}`);s.data&&s.data.id&&await c(e,{id:s.data.id,summary:s.data.summary||"",description:s.data.description||"",location:s.data.location||"",start:s.data.start?{dateTime:s.data.start.dateTime||void 0,date:s.data.start.date||void 0}:void 0,end:s.data.end?{dateTime:s.data.end.dateTime||void 0,date:s.data.end.date||void 0}:void 0,attendees:s.data.attendees?.map(e=>({email:e.email||void 0}))||[]}),s.data&&s.data.id&&await l(e,{id:s.data.id,summary:s.data.summary||"",description:s.data.description||"",location:s.data.location||"",start:s.data.start?{dateTime:s.data.start.dateTime||void 0,date:s.data.start.date||void 0}:void 0,end:s.data.end?{dateTime:s.data.end.dateTime||void 0,date:s.data.end.date||void 0}:void 0,attendees:s.data.attendees?.map(e=>({email:e.email||void 0}))||[]})}catch(e){throw console.error("Error processing calendar update:",e),e}}async function c(e,t){try{let{id:a,summary:o="",description:i="",location:d="",start:c,end:p,attendees:l=[]}=t,u=l?.map(e=>e.email||"").filter(Boolean)||[],m=`${o} ${i} ${d} ${u.join(" ")}`,h=await n(m),w=s(c?.dateTime,c?.date),g=s(p?.dateTime,p?.date),f=await r.z.calendarEvent.findFirst({where:{userId:e,eventId:a}});if(f)await r.z.calendarEvent.update({where:{id:f.id},data:{title:o,description:i||"",location:d,startTime:w,endTime:g,attendees:u,embedding:h}}),console.log(`Updated calendar event: ${f.id}`);else{let t=await r.z.calendarEvent.create({data:{userId:e,eventId:a,title:o,description:i||"",location:d,startTime:w,endTime:g,attendees:u,embedding:h}});console.log(`Created calendar event: ${t.id}`)}}catch(e){throw console.error("Error processing calendar event:",e),e}}async function p(e,t){try{await r.z.calendarEvent.deleteMany({where:{userId:e,eventId:t}}),console.log(`Deleted calendar event: ${t}`)}catch(e){throw console.error(`Error handling deleted event ${t}:`,e),e}}async function l(e,t){let a=await r.z.instruction.findMany({where:{userId:e,active:!0,instruction:{contains:"calendar"}}});if(0===a.length)return;let{id:o,summary:s="",description:n="",location:d="",start:c,end:p,attendees:l=[]}=t;for(let t of a)try{let a=`
        I have a calendar event:
        Title: ${s}
        Description: ${n}
        Location: ${d}
        Start: ${c?.dateTime||c?.date||"Not specified"}
        End: ${p?.dateTime||p?.date||"Not specified"}
        Attendees: ${l?.map(e=>e.email||"").filter(Boolean).join(", ")||"None"}
        
        I have the following instruction: "${t.instruction}"
        
        Should I take any action based on this calendar event and instruction? If yes, what action should I take?
      `,u=await (0,i.E)(e,a,[]);u.toLowerCase().includes("yes")&&!u.toLowerCase().includes("no action")&&await r.z.task.create({data:{userId:e,title:`Process calendar event: ${s}`,description:u,type:"EMAIL",status:"PENDING",metadata:{eventId:o,instructionId:t.id}}})}catch(e){console.error(`Error processing instruction for event ${o}:`,e)}}},10846:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},11723:e=>{e.exports=require("querystring")},12412:e=>{e.exports=require("assert")},16141:e=>{e.exports=require("node:zlib")},19771:e=>{e.exports=require("process")},21099:(e,t,a)=>{a.r(t),a.d(t,{patchFetch:()=>k,routeModule:()=>T,serverHooks:()=>E,workAsyncStorage:()=>$,workUnitAsyncStorage:()=>x});var r={};a.r(r),a.d(r,{GET:()=>I});var o=a(96559),i=a(48088),s=a(37719),n=a(32190),d=a(70132),c=a(11572),p=a(6075),l=a(6111),u=a(75992);let m={};async function h(){try{for(let e of(console.log("Checking for new data..."),await d.z.user.findMany({where:{accounts:{some:{}}},include:{accounts:!0}})))await Promise.all([w(e.id),g(e.id)]);console.log("Finished checking for new data")}catch(e){console.error("Error in proactive agent:",e)}}async function w(e){try{let t=await (0,c.Im)(e);if(!t)return;let a=new Date,r=new Date(a.getTime()-36e5),o=m[e]?.calendar||r,i=(await t.events.list({calendarId:"primary",timeMin:o.toISOString(),timeMax:a.toISOString(),singleEvents:!0,orderBy:"updated",updatedMin:o.toISOString()})).data.items||[];for(let t of i)t.id&&await (0,l.a)(e,{id:t.id,summary:t.summary||"",description:t.description||"",location:t.location||"",start:t.start?{dateTime:t.start.dateTime||void 0,date:t.start.date||void 0}:void 0,end:t.end?{dateTime:t.end.dateTime||void 0,date:t.end.date||void 0}:void 0,attendees:t.attendees?.map(e=>({email:e.email||void 0}))||[]});m[e]||(m[e]={}),m[e].calendar=a,console.log(`Processed ${i.length} calendar events for user ${e}`)}catch(t){console.error(`Error checking calendar events for user ${e}:`,t)}}async function g(e){try{let t=await (0,p.pC)(e);if(!t)return;let a=new Date,r=new Date(a.getTime()-36e5),o=m[e]?.hubspot||r;await f(e,t,o),await y(e,t,o),await v(e,t,o),m[e]||(m[e]={}),m[e].hubspot=a,console.log(`Finished checking HubSpot events for user ${e}`)}catch(t){console.error(`Error checking HubSpot events for user ${e}:`,t)}}async function f(e,t,a){try{let r=(await t.get("/crm/v3/objects/contacts/search",{data:{filterGroups:[{filters:[{propertyName:"createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"contact",eventType:"contact.creation",properties:t.properties};await (0,u.l)(e,a)}console.log(`Processed ${r.length} HubSpot contacts for user ${e}`)}catch(t){console.error(`Error checking HubSpot contacts for user ${e}:`,t)}}async function y(e,t,a){try{let r=(await t.get("/crm/v3/objects/notes/search",{data:{filterGroups:[{filters:[{propertyName:"hs_createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"hs_lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"note",eventType:"note.creation",properties:t.properties};await (0,u.l)(e,a)}console.log(`Processed ${r.length} HubSpot notes for user ${e}`)}catch(t){console.error(`Error checking HubSpot notes for user ${e}:`,t)}}async function v(e,t,a){try{let r=(await t.get("/crm/v3/objects/deals/search",{data:{filterGroups:[{filters:[{propertyName:"createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"hs_lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"deal",eventType:"deal.creation",properties:t.properties};await (0,u.l)(e,a)}console.log(`Processed ${r.length} HubSpot deals for user ${e}`)}catch(t){console.error(`Error checking HubSpot deals for user ${e}:`,t)}}class b{static async startTaskResumptionScheduler(){let e=async()=>{try{let e=(await d.z.task.findMany({where:{status:"WAITING_FOR_RESPONSE",metadata:{path:["resumeAfter"],lte:new Date().toISOString()}},include:{steps:!0}})).map(e=>{let t=e.metadata||{};return{...e,currentStep:t.currentStep||1,steps:e.steps.map((e,t)=>({...e,stepNumber:t+1,metadata:e.metadata||{}})),metadata:t}});await Promise.all(e.map(e=>this.resumeTask(e)))}catch(e){console.error("[TaskManager] Error in task resumption scheduler:",e)}finally{setTimeout(e,6e4)}};e()}static async resumeTask(e){let t=e.metadata||{};return await d.z.task.update({where:{id:e.id},data:{status:"IN_PROGRESS",metadata:{...t,waitingFor:void 0,waitingSince:void 0,resumeAfter:void 0}}}),e.steps?.length&&await Promise.all(e.steps.filter(e=>"WAITING_FOR_RESPONSE"===e.status).map(e=>d.z.taskStep.update({where:{id:e.id},data:{status:"IN_PROGRESS",metadata:{...e.metadata||{},waitingFor:void 0,waitingSince:void 0}}}))),!0}static async manuallyResumeTask(e){let t=await d.z.task.findUnique({where:{id:e},include:{steps:!0}});if(!t)throw Error(`Task ${e} not found`);let a=t.metadata||{};if(!a.waitingFor||!a.waitingSince)throw Error(`Task ${e} is not in a waiting state`);let r={...t,currentStep:a.currentStep||1,steps:t.steps.map((e,t)=>({...e,stepNumber:t+1,metadata:e.metadata||{}})),metadata:a};return this.resumeTask(r)}static async getResumableTasks(){return(await d.z.task.findMany({where:{status:"WAITING_FOR_RESPONSE",metadata:{path:["resumeAfter"],lte:new Date().toISOString()}},include:{steps:!0}})).map(e=>{let t=e.metadata||{};return{...e,currentStep:t.currentStep||1,steps:e.steps.map((e,t)=>({...e,stepNumber:t+1,metadata:e.metadata||{}})),metadata:t}})}static async resumeReadyTasks(){let e=await this.getResumableTasks();return await Promise.all(e.map(e=>this.resumeTask(e))),e}static async updateTaskMetadata(e,t){return d.z.task.update({where:{id:e},data:{metadata:t}})}static async updateStepMetadata(e,t){return d.z.taskStep.update({where:{id:e},data:{metadata:t}})}}let S=!1;async function I(){return n.NextResponse.json({status:"active",message:"Proactive agent is running",timestamp:new Date().toISOString()})}!function(){if(S)return console.log("Server already initialized");console.log("Initializing server components...");try{console.log("Starting proactive agent..."),h(),setInterval(h,9e5),console.log("All agent systems initialized"),b.start(),console.log("Server initialization complete")}catch(e){console.error("Error during server initialization:",e)}S=!0}();let T=new o.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/agent/route",pathname:"/api/agent",filename:"route",bundlePath:"app/api/agent/route"},resolvedPagePath:"C:\\Users\\Joseph\\Documents\\Jump\\jump-advisor\\src\\app\\api\\agent\\route.ts",nextConfigOutput:"",userland:r}),{workAsyncStorage:$,workUnitAsyncStorage:x,serverHooks:E}=T;function k(){return(0,s.patchFetch)({workAsyncStorage:$,workUnitAsyncStorage:x})}},21820:e=>{e.exports=require("os")},27910:e=>{e.exports=require("stream")},28354:e=>{e.exports=require("util")},29021:e=>{e.exports=require("fs")},29294:e=>{e.exports=require("next/dist/server/app-render/work-async-storage.external.js")},33873:e=>{e.exports=require("path")},34631:e=>{e.exports=require("tls")},37067:e=>{e.exports=require("node:http")},37830:e=>{e.exports=require("node:stream/web")},44708:e=>{e.exports=require("node:https")},44870:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},55511:e=>{e.exports=require("crypto")},55591:e=>{e.exports=require("https")},57075:e=>{e.exports=require("node:stream")},57975:e=>{e.exports=require("node:util")},63033:e=>{e.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},73024:e=>{e.exports=require("node:fs")},73136:e=>{e.exports=require("node:url")},73496:e=>{e.exports=require("http2")},73566:e=>{e.exports=require("worker_threads")},74075:e=>{e.exports=require("zlib")},75992:(e,t,a)=>{a.d(t,{l:()=>n});var r=a(70132),o=a(6075),i=a(98504),s=a(94112);async function n(e,t){try{if(console.log(`Processing HubSpot event for user ${e}`,t),!await r.z.account.findFirst({where:{userId:e,provider:"hubspot"}}))throw Error(`No HubSpot account found for user ${e}`);let a=await (0,o.pC)(e),i=t.subscriptionType;switch(i){case"contact.creation":case"contact.propertyChange":await d(e,a,t);break;case"note.creation":await c(e,a,t);break;case"deal.creation":case"deal.propertyChange":await p(e,a,t);break;default:console.log(`Unhandled HubSpot event type: ${i}`)}await l(e,t)}catch(e){throw console.error("Error processing HubSpot event:",e),e}}async function d(e,t,a){try{let o=a.objectId,s=(await t.crm.contacts.basicApi.getById(o,["email","firstname","lastname","phone","company","website","address","city","state","zip"])).body,n=s.properties.email,d=s.properties.firstname,c=s.properties.lastname,p=`${d} ${c} ${n} ${JSON.stringify(s.properties)}`,l=await (0,i.Lu)(p),u=await r.z.hubspotContact.findFirst({where:{userId:e,hubspotId:String(o)}});if(u)await r.z.hubspotContact.update({where:{id:u.id},data:{email:n,firstName:d,lastName:c,properties:s.properties,embedding:l}}),console.log(`Updated HubSpot contact: ${u.id}`);else{let t=await r.z.hubspotContact.create({data:{userId:e,hubspotId:String(o),email:n,firstName:d,lastName:c,properties:s.properties,embedding:l}});console.log(`Created HubSpot contact: ${t.id}`)}}catch(e){throw console.error("Error processing HubSpot contact event:",e),e}}async function c(e,t,a){try{let e=a.objectId,o=(await t.crm.objects.notes.basicApi.getById(e)).body,s=await t.crm.objects.notes.associationsApi.getAll(e,"contact");if(!s.body.results||0===s.body.results.length)return void console.log(`Note ${e} has no associated contact`);let n=s.body.results[0].id,d=o.properties.hs_note_body||"",c=await (0,i.Lu)(d),p=await r.z.hubspotNote.findUnique({where:{hubspotId:String(e)}});if(p)await r.z.hubspotNote.update({where:{id:p.id},data:{content:d,embedding:c}}),console.log(`Updated HubSpot note: ${p.id}`);else{let t=await r.z.hubspotNote.create({data:{hubspotId:String(e),contactId:String(n),content:d,createdAt:new Date(o.properties.hs_createdate||Date.now()),embedding:c}});console.log(`Created HubSpot note: ${t.id}`)}}catch(e){throw console.error("Error processing HubSpot note event:",e),e}}async function p(e,t,a){try{let e=a.objectId,r=(await t.crm.deals.basicApi.getById(e)).body;console.log(`Received deal update: ${e}`,r.properties)}catch(e){throw console.error("Error processing HubSpot deal event:",e),e}}async function l(e,t){let a=(await r.z.instruction.findMany({where:{userId:e,active:!0}})).filter(e=>e.instruction.toLowerCase().includes("hubspot"));if(0!==a.length)for(let o of a)try{let a=`
        I have a HubSpot event:
        Type: ${t.subscriptionType}
        Object ID: ${t.objectId}
        Event ID: ${t.eventId}
        
        I have the following instruction: "${o.instruction}"
        
        Should I take any action based on this HubSpot event and instruction? If yes, what action should I take?
      `,i=await (0,s.E)(e,a,[]);i.toLowerCase().includes("yes")&&!i.toLowerCase().includes("no action")&&await r.z.task.create({data:{userId:e,title:`Process HubSpot event: ${t.subscriptionType}`,description:i,type:"HUBSPOT",status:"PENDING",metadata:{objectId:t.objectId,eventType:t.subscriptionType,instructionId:o.id}}})}catch(e){console.error("Error processing instruction for HubSpot event:",e)}}},76760:e=>{e.exports=require("node:path")},77030:e=>{e.exports=require("node:net")},79428:e=>{e.exports=require("buffer")},79551:e=>{e.exports=require("url")},79646:e=>{e.exports=require("child_process")},81630:e=>{e.exports=require("http")},83997:e=>{e.exports=require("tty")},91645:e=>{e.exports=require("net")},94735:e=>{e.exports=require("events")},96330:e=>{e.exports=require("@prisma/client")}};var t=require("../../../webpack-runtime.js");t.C(e);var a=e=>t(t.s=e),r=t.X(0,[243,580,582,957,112],()=>a(21099));module.exports=r})();