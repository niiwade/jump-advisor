"use strict";(()=>{var e={};e.id=429,e.ids=[429],e.modules={1708:e=>{e.exports=require("node:process")},3295:e=>{e.exports=require("next/dist/server/app-render/after-task-async-storage.external.js")},4573:e=>{e.exports=require("node:buffer")},6111:(e,t,a)=>{a.d(t,{a:()=>c,z:()=>d});var r=a(70132),o=a(11572),i=a(94112);function n(e,t){return e?new Date(e):t?new Date(t):new Date}async function s(e){let t=new(await Promise.resolve().then(a.bind(a,40276))).OpenAI({apiKey:process.env.OPENAI_API_KEY});return(await t.embeddings.create({model:"text-embedding-ada-002",input:e})).data[0].embedding}async function d(e,t,a){try{if(console.log(`Processing calendar update for user ${e}, resource ${t}, state ${a}`),!await r.z.account.findFirst({where:{userId:e,provider:"google"}}))throw Error(`No Google account found for user ${e}`);let i=await (0,o.Im)(e);if("not_exists"===a)return void await l(e,t);let n=await i.events.get({calendarId:"primary",eventId:t});if(!n.data)return void console.log(`No event data found for ${t}`);n.data&&n.data.id&&await c(e,{id:n.data.id,summary:n.data.summary||"",description:n.data.description||"",location:n.data.location||"",start:n.data.start?{dateTime:n.data.start.dateTime||void 0,date:n.data.start.date||void 0}:void 0,end:n.data.end?{dateTime:n.data.end.dateTime||void 0,date:n.data.end.date||void 0}:void 0,attendees:n.data.attendees?.map(e=>({email:e.email||void 0}))||[]}),n.data&&n.data.id&&await u(e,{id:n.data.id,summary:n.data.summary||"",description:n.data.description||"",location:n.data.location||"",start:n.data.start?{dateTime:n.data.start.dateTime||void 0,date:n.data.start.date||void 0}:void 0,end:n.data.end?{dateTime:n.data.end.dateTime||void 0,date:n.data.end.date||void 0}:void 0,attendees:n.data.attendees?.map(e=>({email:e.email||void 0}))||[]})}catch(e){throw console.error("Error processing calendar update:",e),e}}async function c(e,t){try{let{id:a,summary:o="",description:i="",location:d="",start:c,end:l,attendees:u=[]}=t,p=u?.map(e=>e.email||"").filter(Boolean)||[],g=`${o} ${i} ${d} ${p.join(" ")}`,m=await s(g),w=n(c?.dateTime,c?.date),f=n(l?.dateTime,l?.date),S=await r.z.calendarEvent.findFirst({where:{userId:e,eventId:a}});if(S)await r.z.calendarEvent.update({where:{id:S.id},data:{title:o,description:i||"",location:d,startTime:w,endTime:f,attendees:p,embedding:m}}),console.log(`Updated calendar event: ${S.id}`);else{let t=await r.z.calendarEvent.create({data:{userId:e,eventId:a,title:o,description:i||"",location:d,startTime:w,endTime:f,attendees:p,embedding:m}});console.log(`Created calendar event: ${t.id}`)}}catch(e){throw console.error("Error processing calendar event:",e),e}}async function l(e,t){try{await r.z.calendarEvent.deleteMany({where:{userId:e,eventId:t}}),console.log(`Deleted calendar event: ${t}`)}catch(e){throw console.error(`Error handling deleted event ${t}:`,e),e}}async function u(e,t){let a=await r.z.instruction.findMany({where:{userId:e,active:!0,instruction:{contains:"calendar"}}});if(0===a.length)return;let{id:o,summary:n="",description:s="",location:d="",start:c,end:l,attendees:u=[]}=t;for(let t of a)try{let a=`
        I have a calendar event:
        Title: ${n}
        Description: ${s}
        Location: ${d}
        Start: ${c?.dateTime||c?.date||"Not specified"}
        End: ${l?.dateTime||l?.date||"Not specified"}
        Attendees: ${u?.map(e=>e.email||"").filter(Boolean).join(", ")||"None"}
        
        I have the following instruction: "${t.instruction}"
        
        Should I take any action based on this calendar event and instruction? If yes, what action should I take?
      `,p=await (0,i.E)(e,a,[]);p.toLowerCase().includes("yes")&&!p.toLowerCase().includes("no action")&&await r.z.task.create({data:{userId:e,title:`Process calendar event: ${n}`,description:p,type:"EMAIL",status:"PENDING",metadata:{eventId:o,instructionId:t.id}}})}catch(e){console.error(`Error processing instruction for event ${o}:`,e)}}},10846:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},11723:e=>{e.exports=require("querystring")},12412:e=>{e.exports=require("assert")},16141:e=>{e.exports=require("node:zlib")},19771:e=>{e.exports=require("process")},21099:(e,t,a)=>{a.r(t),a.d(t,{patchFetch:()=>F,routeModule:()=>E,serverHooks:()=>R,workAsyncStorage:()=>q,workUnitAsyncStorage:()=>O});var r={};a.r(r),a.d(r,{GET:()=>x});var o=a(96559),i=a(48088),n=a(37719),s=a(32190),d=a(70132),c=a(11572),l=a(6075),u=a(6111),p=a(75992);let g={};async function m(){try{for(let e of(console.log("Checking for new data..."),await d.z.user.findMany({where:{accounts:{some:{}}},include:{accounts:!0}})))await Promise.all([w(e.id),f(e.id)]);console.log("Finished checking for new data")}catch(e){console.error("Error in proactive agent:",e)}}async function w(e){try{let t=await (0,c.Im)(e);if(!t)return;let a=new Date,r=new Date(a.getTime()-36e5),o=g[e]?.calendar||r,i=(await t.events.list({calendarId:"primary",timeMin:o.toISOString(),timeMax:a.toISOString(),singleEvents:!0,orderBy:"updated",updatedMin:o.toISOString()})).data.items||[];for(let t of i)t.id&&await (0,u.a)(e,{id:t.id,summary:t.summary||"",description:t.description||"",location:t.location||"",start:t.start?{dateTime:t.start.dateTime||void 0,date:t.start.date||void 0}:void 0,end:t.end?{dateTime:t.end.dateTime||void 0,date:t.end.date||void 0}:void 0,attendees:t.attendees?.map(e=>({email:e.email||void 0}))||[]});g[e]||(g[e]={}),g[e].calendar=a,console.log(`Processed ${i.length} calendar events for user ${e}`)}catch(t){console.error(`Error checking calendar events for user ${e}:`,t)}}async function f(e){try{let t=await (0,l.pC)(e);if(!t)return;let a=new Date,r=new Date(a.getTime()-36e5),o=g[e]?.hubspot||r;await S(e,t,o),await h(e,t,o),await y(e,t,o),g[e]||(g[e]={}),g[e].hubspot=a,console.log(`Finished checking HubSpot events for user ${e}`)}catch(t){console.error(`Error checking HubSpot events for user ${e}:`,t)}}async function S(e,t,a){try{let r=(await t.get("/crm/v3/objects/contacts/search",{data:{filterGroups:[{filters:[{propertyName:"createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"contact",eventType:"contact.creation",properties:t.properties};await (0,p.l)(e,a)}console.log(`Processed ${r.length} HubSpot contacts for user ${e}`)}catch(t){console.error(`Error checking HubSpot contacts for user ${e}:`,t)}}async function h(e,t,a){try{let r=(await t.get("/crm/v3/objects/notes/search",{data:{filterGroups:[{filters:[{propertyName:"hs_createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"hs_lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"note",eventType:"note.creation",properties:t.properties};await (0,p.l)(e,a)}console.log(`Processed ${r.length} HubSpot notes for user ${e}`)}catch(t){console.error(`Error checking HubSpot notes for user ${e}:`,t)}}async function y(e,t,a){try{let r=(await t.get("/crm/v3/objects/deals/search",{data:{filterGroups:[{filters:[{propertyName:"createdate",operator:"GTE",value:a.toISOString()}]},{filters:[{propertyName:"hs_lastmodifieddate",operator:"GTE",value:a.toISOString()}]}],limit:100}})).data.results||[];for(let t of r){let a={objectId:t.id,objectType:"deal",eventType:"deal.creation",properties:t.properties};await (0,p.l)(e,a)}console.log(`Processed ${r.length} HubSpot deals for user ${e}`)}catch(t){console.error(`Error checking HubSpot deals for user ${e}:`,t)}}var v=a(96330);let b=!1,I=null,T=null;class k{static start(){if(b)return void console.log("Task Manager is already running");console.log("Starting Task Manager service"),b=!0,this.checkWaitingTasks(),T=setInterval(()=>{this.checkWaitingTasks()},6e4)}static stop(){if(!b)return void console.log("Task Manager is not running");console.log("Stopping Task Manager service"),T&&(clearInterval(T),T=null),b=!1}static getStatus(){return{isRunning:b,lastCheckTime:I}}static async checkWaitingTasks(){try{console.log("Checking for waiting tasks that need to be resumed"),I=new Date;let e=await d.z.task.findMany({where:{status:v.TaskStatus.WAITING_FOR_RESPONSE,resumeAfter:{not:null,lt:new Date}},include:{steps:!0}});for(let t of(console.log(`Found ${e.length} tasks to resume`),e))await this.resumeTask(t);return e}catch(e){return console.error("Error checking waiting tasks:",e),[]}}static async resumeTask(e){try{console.log(`Resuming task ${e.id}: ${e.title}`);let t="object"==typeof e.metadata&&null!==e.metadata?{...e.metadata,autoResumed:!0,autoResumeTime:new Date().toISOString(),waitedFor:e.waitingFor,waitingSince:e.waitingSince?.toISOString()}:{autoResumed:!0,autoResumeTime:new Date().toISOString(),waitedFor:e.waitingFor,waitingSince:e.waitingSince?.toISOString()};if(await d.z.task.update({where:{id:e.id},data:{status:v.TaskStatus.IN_PROGRESS,waitingFor:null,waitingSince:null,resumeAfter:null,metadata:t}}),e.steps&&e.steps.length>0){let t=e.steps.find(t=>t.stepNumber===e.currentStep);if(t){let e="object"==typeof t.metadata&&null!==t.metadata?{...t.metadata,autoResumed:!0,autoResumeTime:new Date().toISOString(),waitedFor:t.waitingFor,waitingSince:t.waitingSince?.toISOString()}:{autoResumed:!0,autoResumeTime:new Date().toISOString(),waitedFor:t.waitingFor,waitingSince:t.waitingSince?.toISOString()};await d.z.taskStep.update({where:{id:t.id},data:{status:v.TaskStatus.IN_PROGRESS,waitingFor:null,waitingSince:null,resumeAfter:null,metadata:e}})}}return console.log(`Successfully resumed task ${e.id}`),!0}catch(t){return console.error(`Error resuming task ${e.id}:`,t),!1}}static async manuallyResumeTask(e,t){try{let a=await d.z.task.findUnique({where:{id:e,status:v.TaskStatus.WAITING_FOR_RESPONSE},include:{steps:!0}});if(!a)throw Error("Task not found or not in waiting state");let r="object"==typeof a.metadata&&null!==a.metadata?{...a.metadata,manuallyResumed:!0,manualResumeTime:new Date().toISOString(),userResponse:t||null,waitedFor:a.waitingFor,waitingSince:a.waitingSince?.toISOString()}:{manuallyResumed:!0,manualResumeTime:new Date().toISOString(),userResponse:t||null,waitedFor:a.waitingFor,waitingSince:a.waitingSince?.toISOString()};if(void 0!==t&&"object"==typeof r&&null!==r){let e=Array.isArray(r.responses)?r.responses:[];r.responses=[...e,{timestamp:new Date().toISOString(),response:t,waitedFor:a.waitingFor}]}if(await d.z.task.update({where:{id:e},data:{status:v.TaskStatus.IN_PROGRESS,waitingFor:null,waitingSince:null,resumeAfter:null,metadata:r}}),a.steps&&a.steps.length>0){let e=a.steps.find(e=>e.stepNumber===a.currentStep);if(e){let a="object"==typeof e.metadata&&null!==e.metadata?{...e.metadata,manuallyResumed:!0,manualResumeTime:new Date().toISOString(),userResponse:t||null,waitedFor:e.waitingFor,waitingSince:e.waitingSince?.toISOString()}:{manuallyResumed:!0,manualResumeTime:new Date().toISOString(),userResponse:t||null,waitedFor:e.waitingFor,waitingSince:e.waitingSince?.toISOString()};if(void 0!==t&&"object"==typeof a&&null!==a){let r=Array.isArray(a.responses)?a.responses:[];a.responses=[...r,{timestamp:new Date().toISOString(),response:t,waitedFor:e.waitingFor}]}await d.z.taskStep.update({where:{id:e.id},data:{status:v.TaskStatus.IN_PROGRESS,waitingFor:null,waitingSince:null,resumeAfter:null,metadata:a}})}}return!0}catch(t){return console.error(`Error manually resuming task ${e}:`,t),!1}}}let $=!1;async function x(){return s.NextResponse.json({status:"active",message:"Proactive agent is running",timestamp:new Date().toISOString()})}!function(){if($)return console.log("Server already initialized");console.log("Initializing server components...");try{console.log("Starting proactive agent..."),m(),setInterval(m,9e5),console.log("All agent systems initialized"),k.start(),console.log("Server initialization complete")}catch(e){console.error("Error during server initialization:",e)}$=!0}();let E=new o.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/agent/route",pathname:"/api/agent",filename:"route",bundlePath:"app/api/agent/route"},resolvedPagePath:"C:\\Users\\Joseph\\Documents\\Jump\\jump-advisor\\src\\app\\api\\agent\\route.ts",nextConfigOutput:"",userland:r}),{workAsyncStorage:q,workUnitAsyncStorage:O,serverHooks:R}=E;function F(){return(0,n.patchFetch)({workAsyncStorage:q,workUnitAsyncStorage:O})}},21820:e=>{e.exports=require("os")},27910:e=>{e.exports=require("stream")},28354:e=>{e.exports=require("util")},29021:e=>{e.exports=require("fs")},29294:e=>{e.exports=require("next/dist/server/app-render/work-async-storage.external.js")},33873:e=>{e.exports=require("path")},34631:e=>{e.exports=require("tls")},37067:e=>{e.exports=require("node:http")},37830:e=>{e.exports=require("node:stream/web")},44708:e=>{e.exports=require("node:https")},44870:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},55511:e=>{e.exports=require("crypto")},55591:e=>{e.exports=require("https")},57075:e=>{e.exports=require("node:stream")},57975:e=>{e.exports=require("node:util")},63033:e=>{e.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},73024:e=>{e.exports=require("node:fs")},73136:e=>{e.exports=require("node:url")},73496:e=>{e.exports=require("http2")},73566:e=>{e.exports=require("worker_threads")},74075:e=>{e.exports=require("zlib")},75992:(e,t,a)=>{a.d(t,{l:()=>s});var r=a(70132),o=a(6075),i=a(98504),n=a(94112);async function s(e,t){try{if(console.log(`Processing HubSpot event for user ${e}`,t),!await r.z.account.findFirst({where:{userId:e,provider:"hubspot"}}))throw Error(`No HubSpot account found for user ${e}`);let a=await (0,o.pC)(e),i=t.subscriptionType;switch(i){case"contact.creation":case"contact.propertyChange":await d(e,a,t);break;case"note.creation":await c(e,a,t);break;case"deal.creation":case"deal.propertyChange":await l(e,a,t);break;default:console.log(`Unhandled HubSpot event type: ${i}`)}await u(e,t)}catch(e){throw console.error("Error processing HubSpot event:",e),e}}async function d(e,t,a){try{let o=a.objectId,n=(await t.crm.contacts.basicApi.getById(o,["email","firstname","lastname","phone","company","website","address","city","state","zip"])).body,s=n.properties.email,d=n.properties.firstname,c=n.properties.lastname,l=`${d} ${c} ${s} ${JSON.stringify(n.properties)}`,u=await (0,i.Lu)(l),p=await r.z.hubspotContact.findFirst({where:{userId:e,hubspotId:String(o)}});if(p)await r.z.hubspotContact.update({where:{id:p.id},data:{email:s,firstName:d,lastName:c,properties:n.properties,embedding:u}}),console.log(`Updated HubSpot contact: ${p.id}`);else{let t=await r.z.hubspotContact.create({data:{userId:e,hubspotId:String(o),email:s,firstName:d,lastName:c,properties:n.properties,embedding:u}});console.log(`Created HubSpot contact: ${t.id}`)}}catch(e){throw console.error("Error processing HubSpot contact event:",e),e}}async function c(e,t,a){try{let e=a.objectId,o=(await t.crm.objects.notes.basicApi.getById(e)).body,n=await t.crm.objects.notes.associationsApi.getAll(e,"contact");if(!n.body.results||0===n.body.results.length)return void console.log(`Note ${e} has no associated contact`);let s=n.body.results[0].id,d=o.properties.hs_note_body||"",c=await (0,i.Lu)(d),l=await r.z.hubspotNote.findUnique({where:{hubspotId:String(e)}});if(l)await r.z.hubspotNote.update({where:{id:l.id},data:{content:d,embedding:c}}),console.log(`Updated HubSpot note: ${l.id}`);else{let t=await r.z.hubspotNote.create({data:{hubspotId:String(e),contactId:String(s),content:d,createdAt:new Date(o.properties.hs_createdate||Date.now()),embedding:c}});console.log(`Created HubSpot note: ${t.id}`)}}catch(e){throw console.error("Error processing HubSpot note event:",e),e}}async function l(e,t,a){try{let e=a.objectId,r=(await t.crm.deals.basicApi.getById(e)).body;console.log(`Received deal update: ${e}`,r.properties)}catch(e){throw console.error("Error processing HubSpot deal event:",e),e}}async function u(e,t){let a=(await r.z.instruction.findMany({where:{userId:e,active:!0}})).filter(e=>e.instruction.toLowerCase().includes("hubspot"));if(0!==a.length)for(let o of a)try{let a=`
        I have a HubSpot event:
        Type: ${t.subscriptionType}
        Object ID: ${t.objectId}
        Event ID: ${t.eventId}
        
        I have the following instruction: "${o.instruction}"
        
        Should I take any action based on this HubSpot event and instruction? If yes, what action should I take?
      `,i=await (0,n.E)(e,a,[]);i.toLowerCase().includes("yes")&&!i.toLowerCase().includes("no action")&&await r.z.task.create({data:{userId:e,title:`Process HubSpot event: ${t.subscriptionType}`,description:i,type:"HUBSPOT",status:"PENDING",metadata:{objectId:t.objectId,eventType:t.subscriptionType,instructionId:o.id}}})}catch(e){console.error("Error processing instruction for HubSpot event:",e)}}},76760:e=>{e.exports=require("node:path")},77030:e=>{e.exports=require("node:net")},79428:e=>{e.exports=require("buffer")},79551:e=>{e.exports=require("url")},79646:e=>{e.exports=require("child_process")},81630:e=>{e.exports=require("http")},83997:e=>{e.exports=require("tty")},91645:e=>{e.exports=require("net")},94735:e=>{e.exports=require("events")},96330:e=>{e.exports=require("@prisma/client")}};var t=require("../../../webpack-runtime.js");t.C(e);var a=e=>t(t.s=e),r=t.X(0,[243,580,582,957,112],()=>a(21099));module.exports=r})();